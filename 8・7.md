### RubySilver間違えた問題

### 1

```
次のコードの実行結果として正しいものを選択してください。

IO.read("text.txt", 3, offset = 1)
[text.txtの内容]

REx
Silver
REx
Gold
```

解説には
```
IO.readメソッドは引数に指定したファイルを指定の位置から指定バイト分読み込み文字または文字列として返します。

問題では第1引数で読み込むファイル、第2引数で読み込む文字数、第3引数で読み込み開始位置を指定しています。
```
と書いていた。ということは

開始位置が1文字目で読み込む文字数は3文字なので答えは`Rex`なのだが

読み込む文字数ではなく、読み込む行数と勘違いしており

`"Silver\nREx\nGold\n"`と勘違い。

### 2
```
期待した出力結果になるようにXXXXに適切なコードを選べ

d = Date.new(2015, 1, 5)
puts d.strftime(XXXX)
# 出力結果
01/05/15
```

これは各フォーマットがどのように機能するかがわからなかった。

解説に記載されていた

```
次の表が選択肢で使用されているフォーマット文字列の意味になります。

フォーマット文字列	意味
%x	日付(%m/%d/%y)
%m	月を表す数字(01-12)
%M	分(00-59)
%d	日(01-31)
%D	日付(%m/%d/%y)
%y	西暦の下2桁(00-99)
%Y	西暦を表す数(9999)

```

### 3

```
以下の実行結果となる選択肢を選んでください。

a = [1, 2, 3, 4, 5]
b = [2, 4, 6]
実行結果

[2, 4, 6]

```

`(a - b).map(&:next)`これを選択していたのでこれは正解

ただし

`a&&b`も選択肢に入っていた。

先に解説を。

```
&演算子は左辺と右辺の論理積を返します。

|演算子は左辺と右辺の論理和を返します。

a & b  # => [2, 4]
a | b  # => [1, 2, 3, 4, 5, 6]
論理演算子&&(論理積)は左辺の式で結果が決まる場合、右辺の評価は行わず、最後に評価した値を返します。

1 && nil # => nil
nil && 1 # => nil 右辺は評価されない
Enumerable#mapメソッドは、レシーバの各要素に対して引数で指定した処理を行なった結果を含む配列を返します。

[1, 2, 3].map(&:to_s)                # => ["1", "2", "3"]
[1, 2, 3].map { |n| n + 1 }          # => [2, 3, 4]
Integer#nextメソッドはレシーバの次の整数を返します。

1.next #=> 2
10.next #=> 11
```

真ん中の
`論理演算子&&(論理積)の説明からするに`
この場合だと答えは`2,4なのでは？？`

少し理解ができないままなのが悔しい。



### 4

`Fileクラスのクラスメソッドを選択してください。`

このrexの問題集を解くまで全く耳にすることがなかったFileクラス。

ファイルを開いたりすることができるクラスらしい。

```
File.chmodメソッドは引数に指定したファイルのモードを変更します。

File.deleteメソッドは引数に指定したファイルを削除します。削除に成功した場合は削除したファイルの数を返し、削除に失敗した場合はエラーが発生します。

File.chmod(0644, "text.txt")
# => text.txtファイルのモードを「所有者は読み書き可能で実行不可能」「所有グループとその他は読み込みのみ可能で書き込みと実行は不可能」に変更
# 削除成功
File.delete("text_1.txt", "text2.txt") # => 2

# 削除失敗
File.delete("text_1.txt") # => Errno::ENOENT: No such file or directory @ unlink_internal - text_1.txt
File.pwdメソッドとFile.homeメソッドはFileクラスには存在しません。

File.dirnameは引数に指定した文字列の一番後ろの/より前の文字列を返します。

/を含まない文字列の場合"."を返します。

File.dirname("text.txt") # => "."
File.dirname("REx/text.txt") # => "REx"
File.dirname("Desktop/REx/text.txt") # => "Desktop/REx"
File.closeメソッド, File.homeメソッド, File.pwdメソッドはFileクラスのクラスメソッドではありません。


```

### 5

`Dirクラスのクラスメソッドではないものを選択してください。`


はい。これも知りませんでした。笑

まだまだわからないことが多いなあ。勉強しないと。

```
Dir.pwdメソッドはカレントディレクトリのフルパスを文字列で返します。

例

Dir.pwd # => "/Users/user/RubyExamination"
Dir.directory?, Dir.chmod, Dir.chownはDirクラスのクラスメソッドではありません
```
###  6

`IOクラスのクラスメソッドを選択してください。`

間違ってるのほぼこれ関連。

```
IO.writeメソッドは第1引数に指定したファイルを開き、第2引数に指定した文字列の書き込みを行った後ファイル閉じます。第3引数で書き込み開始位置を指定できます。

IO.readlinesメソッドは引数に指定したファイルの内容を全て読み込み、各行を要素に持つ配列を返します。

IO.write("readme.md", "Ruby\nExamination\n") # => ファイルreadme.mdに第2引数の文字列を書き込みファイルを閉じる
[readme.mdの内容]

Ruby
Examination

IO.readlines("readme.md") # => ["Ruby\n", "Examination\n"]

```

さっき出てたのに笑答えられへんかった...

### 7

```
実行後の textfile.txt 内容になるようにXXXXに適切なコードを選べ。
ただし、空ファイルは作成済みである。

File.open('testfile.txt', XXXX) do |f|
  f.write("recode 1\n")
  f.seek(0, IO::SEEK_SET)
  f.write("recode 2\n")
end
実行後の textfile.txt 内容

recode 1
recode 2

```


Fileクラス問題がすごい弱いように感じておる。

```
w+
recode 2
w+は新規作成・読み込み + 書き込みモードで開きます。
既にファイルが存在する場合は、空になります。
IO#seekはファイルポインタを指定の位置に移動します。IO:SEEK_SETがファイルの先頭からの位置を指定する識別子です。

よって、recode 1を書き込み後にファイルの先頭にファイルポインタを移動し、recode 2で上書きしています。

w
recode 2
wは書き込みモードで開きます。
その他はw+と同様です。

a+
recode 1
recode 2
a+はファイルを読み込みモード + 追記書き込みモードで開きます。
ファイルの読み込みは、ファイルの先頭から行いますが、書き込みは、ファイルの末尾に行います。

a
recode 1
recode 2
aはファイルを追記書き込みモードで開きます。
ファイルの読み込みを行うことはできません。読み込みを行なった場合は、not opened for reading (IOError)が発生します
```
